name: Auto Assign Weekly Picks - Lunes ProgramaciÃ³n + EjecuciÃ³n DinÃ¡mica

# Se ejecuta los lunes a las 17:00 CDMX (23:00 UTC) para programar el auto-assign de la semana
on:
  schedule:
    - cron: '0 23 * * 1'  # Lunes 17:00 CDMX
  
  # Permitir ejecuciÃ³n manual para pruebas
  workflow_dispatch:
    inputs:
      action:
        description: 'AcciÃ³n a ejecutar'
        required: true
        default: 'schedule_and_wait'
        type: choice
        options:
          - schedule_and_wait
          - schedule_only
          - execute_now

env:
  NODE_ENV: production

jobs:
  schedule-auto-assign:
    name: Programar Auto-Assign Semanal
    runs-on: ubuntu-latest
    outputs:
      should_wait: ${{ steps.schedule.outputs.should_wait }}
      execution_timestamp: ${{ steps.schedule.outputs.execution_timestamp }}
      wait_seconds: ${{ steps.schedule.outputs.wait_seconds }}
      last_match_info: ${{ steps.schedule.outputs.last_match_info }}
    
    steps:
      - name: ğŸ“… Log inicio de programaciÃ³n
        run: |
          echo "ğŸš€ PROGRAMANDO AUTO-ASSIGN SEMANAL"
          echo "ğŸ“… Fecha: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          echo "ğŸ¯ AcciÃ³n: ${{ github.event.inputs.action || 'schedule_and_wait' }}"
          echo "ğŸ†” Workflow: ${{ github.run_id }}"
      
      - name: ğŸ“Š Obtener programaciÃ³n del auto-assign
        id: schedule
        run: |
          echo "ğŸ” Consultando Ãºltimo partido de la semana..."
          
          RESPONSE=$(curl -s -w "\n%{http_code}" -X GET \
            "https://${{ secrets.VERCEL_DOMAIN }}/api/schedule-weekly-auto-assign")
          
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          BODY=$(echo "$RESPONSE" | head -n-1)
          
          echo "ğŸ“¡ HTTP Status: $HTTP_CODE"
          echo "ğŸ“„ Response: $BODY"
          
          if [ $HTTP_CODE -eq 200 ]; then
            # Extraer datos del JSON
            EXECUTION_TIMESTAMP=$(echo "$BODY" | jq -r '.execution_schedule.timestamp_utc // 0')
            SHOULD_EXECUTE_NOW=$(echo "$BODY" | jq -r '.execution_schedule.should_execute_now // false')
            MINUTES_UNTIL=$(echo "$BODY" | jq -r '.execution_schedule.minutes_until_execution // 0')
            EXECUTION_TIME_CDMX=$(echo "$BODY" | jq -r '.execution_schedule.execution_time_cdmx // "unknown"')
            LAST_MATCH_ID=$(echo "$BODY" | jq -r '.last_match.id // 0')
            LAST_MATCH_KICKOFF=$(echo "$BODY" | jq -r '.last_match.kickoff_cdmx // "unknown"')
            CURRENT_WEEK=$(echo "$BODY" | jq -r '.current_week // 0')
            
            # Calcular segundos de espera
            NOW=$(date +%s)
            WAIT_SECONDS=$((EXECUTION_TIMESTAMP - NOW))
            
            echo "execution_timestamp=$EXECUTION_TIMESTAMP" >> $GITHUB_OUTPUT
            echo "should_execute_now=$SHOULD_EXECUTE_NOW" >> $GITHUB_OUTPUT
            echo "minutes_until=$MINUTES_UNTIL" >> $GITHUB_OUTPUT
            echo "execution_time_cdmx=$EXECUTION_TIME_CDMX" >> $GITHUB_OUTPUT
            echo "wait_seconds=$WAIT_SECONDS" >> $GITHUB_OUTPUT
            echo "last_match_id=$LAST_MATCH_ID" >> $GITHUB_OUTPUT
            echo "last_match_kickoff=$LAST_MATCH_KICKOFF" >> $GITHUB_OUTPUT
            echo "current_week=$CURRENT_WEEK" >> $GITHUB_OUTPUT
            
            # Determinar si debe esperar
            if [ "${{ github.event.inputs.action }}" = "execute_now" ]; then
              echo "should_wait=false" >> $GITHUB_OUTPUT
              echo "ğŸš€ Modo ejecuciÃ³n inmediata"
            elif [ "${{ github.event.inputs.action }}" = "schedule_only" ]; then
              echo "should_wait=false" >> $GITHUB_OUTPUT
              echo "ğŸ“… Solo programaciÃ³n, sin ejecuciÃ³n"
            elif [ "$SHOULD_EXECUTE_NOW" = "true" ]; then
              echo "should_wait=false" >> $GITHUB_OUTPUT
              echo "âš¡ Debe ejecutarse inmediatamente"
            elif [ $WAIT_SECONDS -gt 0 ] && [ $WAIT_SECONDS -le 21600 ]; then  # MÃ¡ximo 6 horas
              echo "should_wait=true" >> $GITHUB_OUTPUT
              echo "â³ EsperarÃ¡ $WAIT_SECONDS segundos"
            else
              echo "should_wait=false" >> $GITHUB_OUTPUT
              echo "âš ï¸ Tiempo de espera fuera de rango: $WAIT_SECONDS segundos"
            fi
            
            echo "âœ… ProgramaciÃ³n obtenida exitosamente"
            echo "ğŸˆ Ãšltimo partido: ID $LAST_MATCH_ID - $LAST_MATCH_KICKOFF"
            echo "ğŸ“… Semana: $CURRENT_WEEK"
            echo "â° Auto-assign programado: $EXECUTION_TIME_CDMX"
            echo "â³ Minutos restantes: $MINUTES_UNTIL"
            
            # Guardar info para el siguiente job
            echo "last_match_info={\"id\":$LAST_MATCH_ID,\"kickoff\":\"$LAST_MATCH_KICKOFF\",\"week\":$CURRENT_WEEK}" >> $GITHUB_OUTPUT
          else
            echo "âŒ Error obteniendo programaciÃ³n"
            echo "should_wait=false" >> $GITHUB_OUTPUT
          fi

  execute-auto-assign:
    name: Ejecutar Auto-Assign
    runs-on: ubuntu-latest
    needs: schedule-auto-assign
    if: needs.schedule-auto-assign.outputs.should_wait == 'true' || github.event.inputs.action == 'execute_now'
    
    steps:
      - name: â³ Esperar hasta el momento de ejecuciÃ³n
        if: needs.schedule-auto-assign.outputs.should_wait == 'true' && github.event.inputs.action != 'execute_now'
        run: |
          WAIT_SECONDS=${{ needs.schedule-auto-assign.outputs.wait_seconds }}
          EXECUTION_TIME="${{ needs.schedule-auto-assign.outputs.execution_time_cdmx }}"
          
          echo "â° Esperando hasta: $EXECUTION_TIME"
          echo "â³ Segundos de espera: $WAIT_SECONDS"
          
          if [ $WAIT_SECONDS -gt 0 ]; then
            echo "ğŸ˜´ Durmiendo por $WAIT_SECONDS segundos..."
            sleep $WAIT_SECONDS
          fi
          
          echo "âš¡ Â¡Hora de ejecutar el auto-assign!"
      
      - name: ğŸ¯ Ejecutar auto-assign-last-game-picks
        id: auto-assign
        run: |
          echo "ğŸš€ EJECUTANDO AUTO-ASSIGN DE PICKS"
          echo "ğŸ“Š Ãšltimo partido: ${{ needs.schedule-auto-assign.outputs.last_match_info }}"
          
          # Ejecutar con reintentos
          MAX_RETRIES=3
          RETRY_COUNT=0
          SUCCESS=false
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ] && [ "$SUCCESS" = false ]; do
            echo "ğŸ”„ Intento $((RETRY_COUNT + 1))/$MAX_RETRIES - Llamando auto-assign-last-game-picks..."
            
            RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
              "https://${{ secrets.VERCEL_DOMAIN }}/api/auto-assign-last-game-picks" \
              --max-time 45)
            
            HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
            BODY=$(echo "$RESPONSE" | head -n-1)
            
            echo "ğŸ“¡ HTTP Status: $HTTP_CODE"
            echo "ğŸ“„ Response: $BODY"
            
            if [ "$HTTP_CODE" = "200" ]; then
              SUCCESS=true
              echo "âœ… Auto-assign completado exitosamente"
              
              # Extraer informaciÃ³n del resultado
              STATUS=$(echo "$BODY" | jq -r '.status // "unknown"')
              PICKS_ASSIGNED=$(echo "$BODY" | jq -r '.picks_assigned // 0')
              TOTAL_ENTRIES=$(echo "$BODY" | jq -r '.total_entries_without_picks // 0')
              WEEK=$(echo "$BODY" | jq -r '.week // 0')
              
              echo "status=$STATUS" >> $GITHUB_OUTPUT
              echo "picks_assigned=$PICKS_ASSIGNED" >> $GITHUB_OUTPUT
              echo "total_entries=$TOTAL_ENTRIES" >> $GITHUB_OUTPUT
              echo "week=$WEEK" >> $GITHUB_OUTPUT
              
              echo "ğŸ“Š Resultado: $STATUS"
              echo "ğŸ¯ Picks asignados: $PICKS_ASSIGNED de $TOTAL_ENTRIES entradas"
              echo "ğŸ“… Semana: $WEEK"
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "âš ï¸ Intento fallido, reintentando en 15 segundos..."
                sleep 15
              fi
            fi
          done
          
          if [ "$SUCCESS" = false ]; then
            echo "âŒ Error: No se pudo completar auto-assign despuÃ©s de $MAX_RETRIES intentos"
            exit 1
          fi
      
      - name: "ğŸ”„ Post-ejecuciÃ³n: Auto-update picks"
        if: steps.auto-assign.outputs.status == 'completed'
        run: |
          echo "â³ Esperando 30 segundos antes de auto-update-picks..."
          sleep 30
          
          echo "ğŸ”„ Ejecutando auto-update-picks para actualizar resultados..."
          
          RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
            "https://${{ secrets.VERCEL_DOMAIN }}/api/auto-update-picks" \
            --max-time 30)
          
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          BODY=$(echo "$RESPONSE" | head -n-1)
          
          echo "ğŸ“¡ Auto-update Status: $HTTP_CODE"
          echo "ğŸ“„ Response: $BODY"
          
          if [ "$HTTP_CODE" = "200" ]; then
            echo "âœ… Auto-update completado exitosamente"
          else
            echo "âš ï¸ Auto-update retornÃ³ status: $HTTP_CODE (no crÃ­tico)"
          fi

  summary:
    name: Resumen de EjecuciÃ³n
    runs-on: ubuntu-latest
    needs: [schedule-auto-assign, execute-auto-assign]
    if: always()
    
    steps:
      - name: ğŸ“‹ Generar resumen
        run: |
          echo "ğŸ“‹ RESUMEN DE AUTO-ASSIGN SEMANAL"
          echo "================================="
          echo "ğŸ†” Workflow: ${{ github.run_id }}"
          echo "ğŸ“… Fecha: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          echo "ğŸ¯ AcciÃ³n: ${{ github.event.inputs.action || 'schedule_and_wait' }}"
          echo ""
          
          # InformaciÃ³n de programaciÃ³n
          if [ "${{ needs.schedule-auto-assign.result }}" = "success" ]; then
            echo "âœ… ProgramaciÃ³n: Exitosa"
            echo "ğŸ“… Semana: ${{ needs.schedule-auto-assign.outputs.current_week }}"
            echo "â° Tiempo programado: ${{ needs.schedule-auto-assign.outputs.execution_time_cdmx }}"
            echo "ğŸˆ Ãšltimo partido: ${{ needs.schedule-auto-assign.outputs.last_match_info }}"
          else
            echo "âŒ ProgramaciÃ³n: FallÃ³"
          fi
          
          echo ""
          
          # InformaciÃ³n de ejecuciÃ³n
          if [ "${{ needs.execute-auto-assign.result }}" = "success" ]; then
            echo "âœ… EjecuciÃ³n: Exitosa"
            echo "ğŸ¯ Picks asignados: ${{ needs.execute-auto-assign.outputs.picks_assigned }}"
            echo "ğŸ“Š Total entradas: ${{ needs.execute-auto-assign.outputs.total_entries }}"
          elif [ "${{ needs.execute-auto-assign.result }}" = "skipped" ]; then
            echo "â¸ï¸ EjecuciÃ³n: Omitida (solo programaciÃ³n)"
          else
            echo "âŒ EjecuciÃ³n: FallÃ³"
          fi
          
          echo ""
          echo "ğŸ”— Ver detalles: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"