name: NFL Data Automation - Workflows Unificados


on:
  # schedule:
  #   # Martes y Jueves 5:00 AM CDMX (11:00 UTC) - Set current week
  #   - cron: '0 11 * * 2,4'
  #   # Todos los dÃ­as 11:59 PM CDMX (5:59 UTC del dÃ­a siguiente) - Daily update
  #   - cron: '59 5 * * *'
  #   # Todos los dÃ­as 5:30 AM CDMX (11:30 UTC) - Update weekly odds
  #   - cron: '30 11 * * *'
  #   # Lunes 17:45 CDMX (23:45 UTC lunes) - Auto-assign weekly picks
  #   - cron: '45 23 * * 1'
  #   # Domingos 8:00 AM CDMX (14:00 UTC domingo) - Update live scores (partidos matutinos)
  #   - cron: '0 14 * * 0'
  #   # Domingos 13:00 CDMX (19:00 UTC domingo) - Update live scores (partidos vespertinos)
  #   - cron: '0 19 * * 0'
  #   # Domingos 18:00 CDMX (00:00 UTC lunes) - Update live scores (partidos nocturnos)
  #   - cron: '0 0 * * 1'
  #   # Lunes 12:00 PM CDMX (18:00 UTC) - Recordatorio usuarios sin picks
  #   - cron: '0 18 * * 1'
  #   # Martes 12:00 PM CDMX (18:00 UTC) - Enviar resultados semanales
  #   - cron: '0 18 * * 2'
  #   # Jueves 12:00 PM CDMX (18:00 UTC) - Recordatorio a todos los usuarios
  #   - cron: '0 18 * * 4'

  # Permite ejecutar manualmente
  workflow_dispatch:
    inputs:
      task:
        description: 'Tarea a ejecutar'
        required: true
        default: 'all'
        type: choice
        options:
          - all
          - set-current-week
          - daily-update
          - update-weekly-odds
          - auto-update-picks
          - auto-assign-picks
          - save-weekly-records
          - update-live-scores-morning
          - update-live-scores-afternoon
          - update-live-scores-evening
          - send-monday-reminders
          - send-tuesday-results
          - send-thursday-reminders
      force_execution:
        description: 'Forzar ejecuciÃ³n auto-assign (ignora validaciÃ³n de horario)'
        required: false
        default: false
        type: boolean

jobs:
  set-current-week:
    name: Actualizar Semana NFL
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'schedule' && github.event.schedule == '0 11 * * 2,4') || 
      (github.event_name == 'workflow_dispatch' && 
       (github.event.inputs.task == 'set-current-week' || github.event.inputs.task == 'all'))
    
    steps:
      - name: ğŸ“… Actualizar semana actual
        run: |
          echo "ğŸ”„ Actualizando semana actual NFL..."
          
          response=$(curl -L -s -w "\n%{http_code}" -X POST \
            "https://${{ secrets.VERCEL_DOMAIN }}/api/set-current-week" \
            --max-time 30)
          
          http_code=$(echo "$response" | tail -n1)
          body=$(echo "$response" | head -n-1)
          
          echo "ğŸ“¡ HTTP Status: $http_code"
          echo "ğŸ“„ Response: $body"
          
          if [ "$http_code" = "200" ]; then
            echo "âœ… Semana actualizada exitosamente"
          else
            echo "âŒ Error actualizando semana"
            exit 1
          fi

  daily-update:
    name: ActualizaciÃ³n Diaria de Partidos
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'schedule' && github.event.schedule == '59 5 * * *') || 
      (github.event_name == 'workflow_dispatch' && 
       (github.event.inputs.task == 'daily-update' || github.event.inputs.task == 'all'))
    
    outputs:
      update-success: ${{ steps.update-matches.outputs.success }}
    
    steps:
      - name: ğŸˆ Actualizar partidos diariamente
        id: update-matches
        run: |
          echo "ğŸ”„ Ejecutando actualizaciÃ³n diaria de partidos..."
          
          response=$(curl -L -s -w "\n%{http_code}" -X POST \
            "https://${{ secrets.VERCEL_DOMAIN }}/api/update-matches" \
            --max-time 60)
          
          http_code=$(echo "$response" | tail -n1)
          body=$(echo "$response" | head -n-1)
          
          echo "ğŸ“¡ HTTP Status: $http_code"
          echo "ğŸ“„ Response: $body"
          
          if [ "$http_code" = "200" ]; then
            echo "âœ… Partidos actualizados exitosamente"
            echo "success=true" >> $GITHUB_OUTPUT
          else
            echo "âŒ Error actualizando partidos"
            echo "success=false" >> $GITHUB_OUTPUT
            exit 1
          fi

  auto-update-picks:
    name: Auto-Update de Picks (DespuÃ©s de Update Matches)
    runs-on: ubuntu-latest
    needs: daily-update
    if: |
      (needs.daily-update.result == 'success' && needs.daily-update.outputs.update-success == 'true') ||
      (github.event_name == 'workflow_dispatch' && 
       (github.event.inputs.task == 'auto-update-picks' || github.event.inputs.task == 'all'))
    
    steps:
      - name: ğŸ¯ Actualizar picks segÃºn resultados
        run: |
          echo "ğŸ”„ Ejecutando auto-update de picks..."
          echo "â„¹ï¸  Este endpoint solo actualiza picks de partidos completados"
          
          response=$(curl -L -s -w "\n%{http_code}" -X POST \
            "https://${{ secrets.VERCEL_DOMAIN }}/api/auto-update-picks" \
            --max-time 60)
          
          http_code=$(echo "$response" | tail -n1)
          body=$(echo "$response" | head -n-1)
          
          echo "ğŸ“¡ HTTP Status: $http_code"
          echo "ğŸ“„ Response: $body"
          
          if [ "$http_code" = "200" ]; then
            echo "âœ… Picks actualizados exitosamente"
            
            # Extraer informaciÃ³n del resultado
            picks_updated=$(echo "$body" | jq -r '.picks_updated // 0' 2>/dev/null || echo "0")
            entries_updated=$(echo "$body" | jq -r '.entries_updated // 0' 2>/dev/null || echo "0")
            
            echo "ğŸ¯ Picks actualizados: $picks_updated"
            echo "ğŸ‘¥ Entradas actualizadas: $entries_updated"
          else
            echo "âŒ Error actualizando picks"
            exit 1
          fi

  update-weekly-odds:
    name: Actualizar Momios Semanales
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'schedule' && github.event.schedule == '30 11 * * *') || 
      (github.event_name == 'workflow_dispatch' && 
       (github.event.inputs.task == 'update-weekly-odds' || github.event.inputs.task == 'all'))
    
    steps:
      - name: ğŸ“Š Actualizar momios semanales
        run: |
          echo "ğŸ”„ Actualizando momios semanales..."
          
          response=$(curl -L -s -w "\n%{http_code}" -X POST \
            "https://${{ secrets.VERCEL_DOMAIN }}/api/update-weekly-odds-auto" \
            --max-time 45)
          
          http_code=$(echo "$response" | tail -n1)
          body=$(echo "$response" | head -n-1)
          
          echo "ğŸ“¡ HTTP Status: $http_code"
          echo "ğŸ“„ Response: $body"
          
          if [ "$http_code" = "200" ]; then
            echo "âœ… Momios actualizados exitosamente"
          else
            echo "âŒ Error actualizando momios"
            exit 1
          fi

  save-weekly-records:
    name: Guardar Records Semanales
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'workflow_dispatch' && 
      (github.event.inputs.task == 'save-weekly-records' || github.event.inputs.task == 'all')
    
    steps:
      - name: ğŸ“Š Obtener informaciÃ³n de temporada
        id: season-info
        run: |
          echo "ğŸ” Obteniendo informaciÃ³n de la temporada actual..."
          
          season_info=$(curl -L -s "https://${{ secrets.VERCEL_DOMAIN }}/api/current-week" --max-time 30)
          
          if [ $? -eq 0 ]; then
            year=$(echo "$season_info" | jq -r '.season_year // 2024' 2>/dev/null || echo "2024")
            week=$(echo "$season_info" | jq -r '.current_week // 1' 2>/dev/null || echo "1")
            
            # Calcular semana anterior para guardar records
            week_to_save=$((week - 1))
            if [ $week_to_save -lt 1 ]; then
              week_to_save=1
            fi
            
            echo "year=$year" >> $GITHUB_OUTPUT
            echo "week_to_save=$week_to_save" >> $GITHUB_OUTPUT
            
            echo "ğŸ“… AÃ±o: $year"
            echo "ğŸ“Š Semana a guardar: $week_to_save"
          else
            echo "âŒ Error obteniendo informaciÃ³n de temporada"
            echo "year=2024" >> $GITHUB_OUTPUT
            echo "week_to_save=1" >> $GITHUB_OUTPUT
          fi
      
      - name: ğŸ’¾ Guardar records semanales
        run: |
          echo "ğŸ”„ Guardando records semanales..."
          
          year="${{ steps.season-info.outputs.year }}"
          
          response=$(curl -L -s -w "\n%{http_code}" -X POST \
            "https://${{ secrets.VERCEL_DOMAIN }}/api/save-weekly-team-records?year=$year" \
            --max-time 45)
          
          http_code=$(echo "$response" | tail -n1)
          body=$(echo "$response" | head -n-1)
          
          echo "ğŸ“¡ HTTP Status: $http_code"
          echo "ğŸ“„ Response: $body"
          
          if [ "$http_code" = "200" ]; then
            echo "âœ… Records guardados exitosamente"
          else
            echo "âŒ Error guardando records"
            exit 1
          fi

  auto-assign-picks:
    name: Auto-Assign Picks Semanal
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'schedule' && github.event.schedule == '45 23 * * 1') || 
      (github.event_name == 'workflow_dispatch' && 
       (github.event.inputs.task == 'auto-assign-picks' || github.event.inputs.task == 'all'))
    
    steps:
      - name: ğŸ“… Log inicio
        run: |
          echo "ğŸš€ AUTO-ASSIGN SEMANAL DE PICKS"
          echo "ğŸ“… Fecha inicio: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          echo "ğŸ¯ Workflow: ${{ github.run_id }}"
      
      - name: ğŸ“Š Obtener horario del Ãºltimo partido
        id: get-schedule
        run: |
          echo "ğŸ” Consultando horario del Ãºltimo partido de la semana..."
          
          response=$(curl -L -s -w "\n%{http_code}" -X GET \
            "https://${{ secrets.VERCEL_DOMAIN }}/api/schedule-weekly-auto-assign" \
            --max-time 30)
          
          http_code=$(echo "$response" | tail -n1)
          body=$(echo "$response" | head -n-1)
          
          echo "ğŸ“¡ HTTP Status: $http_code"
          echo "ğŸ“„ Response: $body"
          
          if [ "$http_code" = "200" ]; then
            minutes_until_raw=$(echo "$body" | jq -r '.execution_schedule.minutes_until_execution // 0' 2>/dev/null || echo "0")
            minutes_until=$(printf "%.0f" "$minutes_until_raw" 2>/dev/null || echo "0")
            execution_time=$(echo "$body" | jq -r '.execution_schedule.execution_time_cdmx // "unknown"' 2>/dev/null || echo "unknown")
            current_week=$(echo "$body" | jq -r '.current_week // 0' 2>/dev/null || echo "0")
            last_match_kickoff=$(echo "$body" | jq -r '.last_match.kickoff_cdmx // "unknown"' 2>/dev/null || echo "unknown")
            
            echo "ğŸˆ Ãšltimo partido inicia: $last_match_kickoff"
            echo "â° Auto-assign programado para: $execution_time (5 min despuÃ©s)"
            echo "ğŸ“… Semana NFL: $current_week"
            echo "â³ Minutos de espera: $minutes_until"
            
            # Guardar valores para el siguiente step
            echo "minutes_until=$minutes_until" >> $GITHUB_OUTPUT
            echo "execution_time=$execution_time" >> $GITHUB_OUTPUT
            echo "current_week=$current_week" >> $GITHUB_OUTPUT
            echo "last_match_kickoff=$last_match_kickoff" >> $GITHUB_OUTPUT
          else
            echo "âŒ Error consultando programaciÃ³n"
            exit 1
          fi
      
      - name: â° Esperar hasta momento de ejecuciÃ³n
        run: |
          minutes_until=${{ steps.get-schedule.outputs.minutes_until }}
          execution_time="${{ steps.get-schedule.outputs.execution_time }}"
          
          # Si force_execution estÃ¡ activado, no esperar
          if [ "${{ github.event.inputs.force_execution }}" = "true" ]; then
            echo "ğŸš€ EjecuciÃ³n forzada - omitiendo espera"
          elif [ "$minutes_until" -le 0 ]; then
            echo "âœ… Ya pasÃ³ el tiempo de ejecuciÃ³n - ejecutando inmediatamente"
          else
            # MÃ¡ximo 6 horas de espera (360 minutos) para evitar timeout de GitHub Actions
            if [ "$minutes_until" -gt 360 ]; then
              echo "âš ï¸ Tiempo de espera ($minutes_until min) excede lÃ­mite de 6 horas"
              echo "âŒ El workflow debe ejecutarse mÃ¡s cerca del horario del partido"
              exit 1
            fi
            
            # Convertir minutos a segundos
            seconds_to_wait=$((minutes_until * 60))
            
            echo "â³ Esperando $minutes_until minutos ($seconds_to_wait segundos) hasta $execution_time..."
            echo "ğŸ• Inicio de espera: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
            
            # Esperar
            sleep $seconds_to_wait
            
            echo "âœ… Espera completada"
            echo "ğŸ• Fin de espera: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          fi
      
      - name: ğŸ¯ Ejecutar auto-assign de picks
        run: |
          echo "ğŸš€ EJECUTANDO AUTO-ASSIGN DE PICKS"
          echo "ğŸ• Hora de ejecuciÃ³n: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          
          # Ejecutar con reintentos
          max_retries=3
          retry_count=0
          success=false
          
          while [ $retry_count -lt $max_retries ] && [ "$success" = "false" ]; do
            echo "ğŸ”„ Intento $((retry_count + 1))/$max_retries..."
            
            response=$(curl -L -s -w "\n%{http_code}" -X POST \
              "https://${{ secrets.VERCEL_DOMAIN }}/api/auto-assign-last-game-picks" \
              --max-time 60)
            
            http_code=$(echo "$response" | tail -n1)
            body=$(echo "$response" | head -n-1)
            
            echo "ğŸ“¡ HTTP Status: $http_code"
            echo "ğŸ“„ Response: $body"
            
            if [ "$http_code" = "200" ]; then
              success=true
              echo "âœ… Auto-assign completado exitosamente"
              
              # Extraer informaciÃ³n del resultado
              picks_assigned=$(echo "$body" | jq -r '.picks_assigned // 0' 2>/dev/null || echo "0")
              total_entries=$(echo "$body" | jq -r '.total_entries_without_picks // 0' 2>/dev/null || echo "0")
              week=$(echo "$body" | jq -r '.week // 0' 2>/dev/null || echo "0")
              
              echo "ğŸ“Š RESULTADO:"
              echo "   ğŸ¯ Picks asignados: $picks_assigned"
              echo "   ğŸ“‹ Entradas sin pick: $total_entries"
              echo "   ğŸ“… Semana: $week"
            else
              retry_count=$((retry_count + 1))
              if [ $retry_count -lt $max_retries ]; then
                echo "âš ï¸ Intento fallido, esperando 20 segundos antes de reintentar..."
                sleep 20
              fi
            fi
          done
          
          if [ "$success" = "false" ]; then
            echo "âŒ Error: No se pudo completar auto-assign despuÃ©s de $max_retries intentos"
            exit 1
          fi
      
      - name:  Resumen final
        if: always()
        run: |
          echo "ğŸ“‹ RESUMEN DE AUTO-ASSIGN SEMANAL"
          echo "================================="
          echo "ğŸ†” Workflow: ${{ github.run_id }}"
          echo "ğŸ“… Fecha final: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          echo "ï¿½ Ãšltimo partido: ${{ steps.get-schedule.outputs.last_match_kickoff }}"
          echo "â° Tiempo de ejecuciÃ³n: ${{ steps.get-schedule.outputs.execution_time }}"
          echo "ğŸ“… Semana NFL: ${{ steps.get-schedule.outputs.current_week }}"
          echo "ğŸ¯ Forzado: ${{ github.event.inputs.force_execution || 'false' }}"
          echo ""
          echo "ğŸ”— Detalles: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"

  update-live-scores-morning:
    name: ActualizaciÃ³n de Scores en Vivo (Domingos - MaÃ±ana 8:00-13:00)
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'schedule' && github.event.schedule == '0 14 * * 0') || 
      (github.event_name == 'workflow_dispatch' && 
       github.event.inputs.task == 'update-live-scores-morning')
    
    steps:
      - name: ğŸ“… Log inicio
        run: |
          echo "ğŸš€ UPDATE LIVE SCORES - DOMINGOS NFL (MAÃ‘ANA)"
          echo "ğŸ“… Fecha inicio: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          echo "ğŸ¯ Workflow: ${{ github.run_id }}"
          echo "â° Periodo: 8:00 AM - 13:00 PM CDMX"
      
      - name: ğŸ”„ Loop de actualizaciÃ³n de scores en vivo (5 horas)
        run: |
          echo "ğŸš€ INICIANDO LOOP DE ACTUALIZACIÃ“N - PERIODO MATUTINO"
          echo "â° Se ejecutarÃ¡ cada 2 minutos por mÃ¡ximo 5 horas"
          
          start_time=$(date +%s)
          max_duration=$((5 * 60 * 60))  # 5 horas en segundos
          iteration=0
          max_iterations=150  # 150 iteraciones = 5 horas (150 * 2 min = 300 min)
          
          while [ $iteration -lt $max_iterations ]; do
            current_time=$(date +%s)
            elapsed=$((current_time - start_time))
            
            # Verificar si ya pasaron 5 horas
            if [ $elapsed -ge $max_duration ]; then
              echo "â° Se alcanzÃ³ el lÃ­mite de 5 horas de ejecuciÃ³n"
              break
            fi
            
            iteration=$((iteration + 1))
            echo ""
            echo "ğŸ”„ IteraciÃ³n #$iteration - $(date -u +'%Y-%m-%d %H:%M:%S UTC') - Tiempo transcurrido: $((elapsed / 60)) min"
            
            # Ejecutar actualizaciÃ³n de scores
            response=$(curl -L -s -w "\n%{http_code}" -X POST \
              "https://${{ secrets.VERCEL_DOMAIN }}/api/update-live-scores" \
              --max-time 30)
            
            http_code=$(echo "$response" | tail -n1)
            body=$(echo "$response" | head -n-1)
            
            echo "ğŸ“¡ HTTP Status: $http_code"
            
            if [ "$http_code" = "200" ]; then
              # Extraer informaciÃ³n del resultado
              status=$(echo "$body" | jq -r '.status // "unknown"' 2>/dev/null || echo "unknown")
              matches_updated=$(echo "$body" | jq -r '.matches_updated // 0' 2>/dev/null || echo "0")
              live_matches=$(echo "$body" | jq -r '.live_matches_found // 0' 2>/dev/null || echo "0")
              
              echo "ğŸ“Š Estado: $status"
              echo "ğŸˆ Partidos en vivo: $live_matches"
              echo "âœ… Partidos actualizados: $matches_updated"
              
              # Si no hay partidos en vivo, continuar esperando (pueden empezar mÃ¡s tarde)
              if [ "$status" = "no_live_matches" ]; then
                echo "â„¹ï¸  No hay partidos en vivo aÃºn, continuando monitoreo..."
              fi
            else
              echo "âš ï¸ Error en la actualizaciÃ³n, continuando..."
            fi
            
            # Esperar 2 minutos antes de la siguiente iteraciÃ³n
            if [ $iteration -lt $max_iterations ]; then
              remaining_time=$((max_duration - elapsed))
              if [ $remaining_time -gt 120 ]; then
                echo "â³ Esperando 2 minutos para la siguiente actualizaciÃ³n..."
                sleep 120
              else
                echo "â° Tiempo restante menor a 2 minutos, finalizando..."
                break
              fi
            fi
          done
          
          echo ""
          echo "âœ… LOOP DE ACTUALIZACIÃ“N MATUTINO COMPLETADO"
          echo "ğŸ“Š Total de iteraciones: $iteration"
          echo "â±ï¸  Tiempo total: $((elapsed / 60)) minutos"
      
      - name: ğŸ“‹ Resumen final
        if: always()
        run: |
          echo "ğŸ“‹ RESUMEN DE ACTUALIZACIÃ“N MATUTINA (8:00-13:00 CDMX)"
          echo "====================================================="
          echo "ğŸ†” Workflow: ${{ github.run_id }}"
          echo "ğŸ“… Fecha final: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          echo "â° Periodo: Partidos matutinos"
          echo ""
          echo "ğŸ”— Detalles: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"

  update-live-scores-afternoon:
    name: ActualizaciÃ³n de Scores en Vivo (Domingos - Tarde 13:00-18:00)
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'schedule' && github.event.schedule == '0 19 * * 0') || 
      (github.event_name == 'workflow_dispatch' && 
       github.event.inputs.task == 'update-live-scores-afternoon')
    
    steps:
      - name: ğŸ“… Log inicio
        run: |
          echo "ğŸš€ UPDATE LIVE SCORES - DOMINGOS NFL (TARDE)"
          echo "ğŸ“… Fecha inicio: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          echo "ğŸ¯ Workflow: ${{ github.run_id }}"
          echo "â° Periodo: 13:00 PM - 18:00 PM CDMX"
      
      - name: ğŸ”„ Loop de actualizaciÃ³n de scores en vivo (5 horas)
        run: |
          echo "ğŸš€ INICIANDO LOOP DE ACTUALIZACIÃ“N - PERIODO VESPERTINO"
          echo "â° Se ejecutarÃ¡ cada 2 minutos por mÃ¡ximo 5 horas"
          
          start_time=$(date +%s)
          max_duration=$((5 * 60 * 60))  # 5 horas en segundos
          iteration=0
          max_iterations=150  # 150 iteraciones = 5 horas
          
          while [ $iteration -lt $max_iterations ]; do
            current_time=$(date +%s)
            elapsed=$((current_time - start_time))
            
            # Verificar si ya pasaron 5 horas
            if [ $elapsed -ge $max_duration ]; then
              echo "â° Se alcanzÃ³ el lÃ­mite de 5 horas de ejecuciÃ³n"
              break
            fi
            
            iteration=$((iteration + 1))
            echo ""
            echo "ğŸ”„ IteraciÃ³n #$iteration - $(date -u +'%Y-%m-%d %H:%M:%S UTC') - Tiempo transcurrido: $((elapsed / 60)) min"
            
            # Ejecutar actualizaciÃ³n de scores
            response=$(curl -L -s -w "\n%{http_code}" -X POST \
              "https://${{ secrets.VERCEL_DOMAIN }}/api/update-live-scores" \
              --max-time 30)
            
            http_code=$(echo "$response" | tail -n1)
            body=$(echo "$response" | head -n-1)
            
            echo "ğŸ“¡ HTTP Status: $http_code"
            
            if [ "$http_code" = "200" ]; then
              status=$(echo "$body" | jq -r '.status // "unknown"' 2>/dev/null || echo "unknown")
              matches_updated=$(echo "$body" | jq -r '.matches_updated // 0' 2>/dev/null || echo "0")
              live_matches=$(echo "$body" | jq -r '.live_matches_found // 0' 2>/dev/null || echo "0")
              
              echo "ğŸ“Š Estado: $status"
              echo "ğŸˆ Partidos en vivo: $live_matches"
              echo "âœ… Partidos actualizados: $matches_updated"
              
              if [ "$status" = "no_live_matches" ]; then
                echo "â„¹ï¸  No hay partidos en vivo aÃºn, continuando monitoreo..."
              fi
            else
              echo "âš ï¸ Error en la actualizaciÃ³n, continuando..."
            fi
            
            # Esperar 2 minutos antes de la siguiente iteraciÃ³n
            if [ $iteration -lt $max_iterations ]; then
              remaining_time=$((max_duration - elapsed))
              if [ $remaining_time -gt 120 ]; then
                echo "â³ Esperando 2 minutos para la siguiente actualizaciÃ³n..."
                sleep 120
              else
                echo "â° Tiempo restante menor a 2 minutos, finalizando..."
                break
              fi
            fi
          done
          
          echo ""
          echo "âœ… LOOP DE ACTUALIZACIÃ“N VESPERTINO COMPLETADO"
          echo "ğŸ“Š Total de iteraciones: $iteration"
          echo "â±ï¸  Tiempo total: $((elapsed / 60)) minutos"
      
      - name: ğŸ“‹ Resumen final
        if: always()
        run: |
          echo "ğŸ“‹ RESUMEN DE ACTUALIZACIÃ“N VESPERTINA (13:00-18:00 CDMX)"
          echo "======================================================="
          echo "ğŸ†” Workflow: ${{ github.run_id }}"
          echo "ğŸ“… Fecha final: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          echo "â° Periodo: Partidos vespertinos"
          echo ""
          echo "ğŸ”— Detalles: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"

  update-live-scores-evening:
    name: ActualizaciÃ³n de Scores en Vivo (Domingos - Noche 18:00-22:00)
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'schedule' && github.event.schedule == '0 0 * * 1') || 
      (github.event_name == 'workflow_dispatch' && 
       github.event.inputs.task == 'update-live-scores-evening')
    
    steps:
      - name: ğŸ“… Log inicio
        run: |
          echo "ğŸš€ UPDATE LIVE SCORES - DOMINGOS NFL (NOCHE)"
          echo "ğŸ“… Fecha inicio: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          echo "ğŸ¯ Workflow: ${{ github.run_id }}"
          echo "â° Periodo: 18:00 PM - 22:00 PM CDMX"
      
      - name: ğŸ”„ Loop de actualizaciÃ³n de scores en vivo (4 horas)
        run: |
          echo "ğŸš€ INICIANDO LOOP DE ACTUALIZACIÃ“N - PERIODO NOCTURNO"
          echo "â° Se ejecutarÃ¡ cada 2 minutos por mÃ¡ximo 4 horas"
          
          start_time=$(date +%s)
          max_duration=$((4 * 60 * 60))  # 4 horas en segundos
          iteration=0
          max_iterations=120  # 120 iteraciones = 4 horas
          
          while [ $iteration -lt $max_iterations ]; do
            current_time=$(date +%s)
            elapsed=$((current_time - start_time))
            
            # Verificar si ya pasaron 4 horas
            if [ $elapsed -ge $max_duration ]; then
              echo "â° Se alcanzÃ³ el lÃ­mite de 4 horas de ejecuciÃ³n"
              break
            fi
            
            iteration=$((iteration + 1))
            echo ""
            echo "ğŸ”„ IteraciÃ³n #$iteration - $(date -u +'%Y-%m-%d %H:%M:%S UTC') - Tiempo transcurrido: $((elapsed / 60)) min"
            
            # Ejecutar actualizaciÃ³n de scores
            response=$(curl -L -s -w "\n%{http_code}" -X POST \
              "https://${{ secrets.VERCEL_DOMAIN }}/api/update-live-scores" \
              --max-time 30)
            
            http_code=$(echo "$response" | tail -n1)
            body=$(echo "$response" | head -n-1)
            
            echo "ğŸ“¡ HTTP Status: $http_code"
            
            if [ "$http_code" = "200" ]; then
              status=$(echo "$body" | jq -r '.status // "unknown"' 2>/dev/null || echo "unknown")
              matches_updated=$(echo "$body" | jq -r '.matches_updated // 0' 2>/dev/null || echo "0")
              live_matches=$(echo "$body" | jq -r '.live_matches_found // 0' 2>/dev/null || echo "0")
              
              echo "ğŸ“Š Estado: $status"
              echo "ğŸˆ Partidos en vivo: $live_matches"
              echo "âœ… Partidos actualizados: $matches_updated"
              
              # En el periodo nocturno, si no hay partidos ya podemos terminar
              if [ "$status" = "no_live_matches" ]; then
                echo "âœ… No hay mÃ¡s partidos en vivo - Todos los partidos del domingo han finalizado"
                break
              fi
            else
              echo "âš ï¸ Error en la actualizaciÃ³n, continuando..."
            fi
            
            # Esperar 2 minutos antes de la siguiente iteraciÃ³n
            if [ $iteration -lt $max_iterations ]; then
              remaining_time=$((max_duration - elapsed))
              if [ $remaining_time -gt 120 ]; then
                echo "â³ Esperando 2 minutos para la siguiente actualizaciÃ³n..."
                sleep 120
              else
                echo "â° Tiempo restante menor a 2 minutos, finalizando..."
                break
              fi
            fi
          done
          
          echo ""
          echo "âœ… LOOP DE ACTUALIZACIÃ“N NOCTURNO COMPLETADO"
          echo "ğŸ“Š Total de iteraciones: $iteration"
          echo "â±ï¸  Tiempo total: $((elapsed / 60)) minutos"
      
      - name: ğŸ Marcar partidos del domingo como completados
        run: |
          echo "ğŸ”„ Marcando todos los partidos del domingo como completados..."
          
          response=$(curl -L -s -w "\n%{http_code}" -X POST \
            "https://${{ secrets.VERCEL_DOMAIN }}/api/complete-sunday-matches" \
            --max-time 30)
          
          http_code=$(echo "$response" | tail -n1)
          body=$(echo "$response" | head -n-1)
          
          echo "ğŸ“¡ HTTP Status: $http_code"
          echo "ğŸ“„ Response: $body"
          
          if [ "$http_code" = "200" ]; then
            matches_completed=$(echo "$body" | jq -r '.matches_completed // 0' 2>/dev/null || echo "0")
            echo "âœ… Partidos marcados como completados: $matches_completed"
          else
            echo "âš ï¸ Error al marcar partidos como completados"
          fi
      
      - name: ğŸ“‹ Resumen final
        if: always()
        run: |
          echo "ğŸ“‹ RESUMEN DE ACTUALIZACIÃ“N NOCTURNA (18:00-22:00 CDMX)"
          echo "======================================================="
          echo "ğŸ†” Workflow: ${{ github.run_id }}"
          echo "ğŸ“… Fecha final: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          echo "â° Periodo: Partidos nocturnos (Ãºltimo periodo del dÃ­a)"
          echo "ğŸ Fin de jornada dominical"
          echo ""
          echo "ğŸ”— Detalles: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"

  send-monday-reminders:
    name: Recordatorio Lunes - Usuarios Sin Picks
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'schedule' && github.event.schedule == '0 18 * * 1') || 
      (github.event_name == 'workflow_dispatch' && 
       github.event.inputs.task == 'send-monday-reminders')
    
    steps:
      - name: ğŸ“§ Enviar recordatorios a usuarios sin picks
        run: |
          echo "ğŸ“§ RECORDATORIO LUNES - USUARIOS SIN PICKS"
          echo "ğŸ“… Fecha: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          echo "ğŸ¯ Modo: auto_no_picks_only"
          
          response=$(curl -L -s -w "\n%{http_code}" -X POST \
            "${{ secrets.SUPABASE_URL }}/functions/v1/send-weekly-reminders" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer ${{ secrets.SUPABASE_ANON_KEY }}" \
            -d '{"mode":"auto_no_picks_only"}' \
            --max-time 300)
          
          http_code=$(echo "$response" | tail -n1)
          body=$(echo "$response" | head -n-1)
          
          echo "ğŸ“¡ HTTP Status: $http_code"
          echo "ğŸ“„ Response: $body"
          
          if [ "$http_code" = "200" ]; then
            total_processed=$(echo "$body" | jq -r '.total_processed // 0' 2>/dev/null || echo "0")
            successful=$(echo "$body" | jq -r '.successful // 0' 2>/dev/null || echo "0")
            failed=$(echo "$body" | jq -r '.failed // 0' 2>/dev/null || echo "0")
            
            echo "âœ… Recordatorios enviados exitosamente"
            echo "ğŸ“Š Total procesados: $total_processed"
            echo "âœ… Exitosos: $successful"
            echo "âŒ Fallidos: $failed"
          else
            echo "âŒ Error enviando recordatorios"
            exit 1
          fi

  send-tuesday-results:
    name: Resultados Martes - EnvÃ­o Semanal
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'schedule' && github.event.schedule == '0 18 * * 2') || 
      (github.event_name == 'workflow_dispatch' && 
       github.event.inputs.task == 'send-tuesday-results')
    
    steps:
      - name: ğŸ“Š Obtener semana actual
        id: get-week
        run: |
          echo "ğŸ” Obteniendo informaciÃ³n de la temporada actual..."
          
          season_info=$(curl -L -s "https://${{ secrets.VERCEL_DOMAIN }}/api/current-week" --max-time 30)
          
          if [ $? -eq 0 ]; then
            current_week=$(echo "$season_info" | jq -r '.current_week // 1' 2>/dev/null || echo "1")
            
            # Calcular semana anterior para enviar resultados
            previous_week=$((current_week - 1))
            if [ $previous_week -lt 1 ]; then
              previous_week=1
            fi
            
            echo "week_to_send=$previous_week" >> $GITHUB_OUTPUT
            
            echo "ğŸ“… Semana actual: $current_week"
            echo "ğŸ“Š Semana a enviar resultados: $previous_week"
          else
            echo "âŒ Error obteniendo informaciÃ³n de temporada"
            echo "week_to_send=1" >> $GITHUB_OUTPUT
          fi
      
      - name: ğŸ“Š Enviar resultados semanales
        run: |
          echo "ğŸ“Š RESULTADOS SEMANALES - MARTES"
          echo "ğŸ“… Fecha: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          echo "ğŸ¯ Modo: auto_all_users"
          echo "ğŸ“… Semana: ${{ steps.get-week.outputs.week_to_send }}"
          
          response=$(curl -L -s -w "\n%{http_code}" -X POST \
            "${{ secrets.SUPABASE_URL }}/functions/v1/send-weekly-results" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer ${{ secrets.SUPABASE_ANON_KEY }}" \
            -d '{"mode":"auto_all_users","week":${{ steps.get-week.outputs.week_to_send }}}' \
            --max-time 300)
          
          http_code=$(echo "$response" | tail -n1)
          body=$(echo "$response" | head -n-1)
          
          echo "ğŸ“¡ HTTP Status: $http_code"
          echo "ğŸ“„ Response: $body"
          
          if [ "$http_code" = "200" ]; then
            total_processed=$(echo "$body" | jq -r '.total_processed // 0' 2>/dev/null || echo "0")
            successful=$(echo "$body" | jq -r '.successful // 0' 2>/dev/null || echo "0")
            failed=$(echo "$body" | jq -r '.failed // 0' 2>/dev/null || echo "0")
            
            echo "âœ… Resultados enviados exitosamente"
            echo "ğŸ“Š Total procesados: $total_processed"
            echo "âœ… Exitosos: $successful"
            echo "âŒ Fallidos: $failed"
          else
            echo "âŒ Error enviando resultados"
            exit 1
          fi

  send-thursday-reminders:
    name: Recordatorio Jueves - Todos los Usuarios
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'schedule' && github.event.schedule == '0 18 * * 4') || 
      (github.event_name == 'workflow_dispatch' && 
       github.event.inputs.task == 'send-thursday-reminders')
    
    steps:
      - name: ğŸ“§ Enviar recordatorios a todos los usuarios
        run: |
          echo "ğŸ“§ RECORDATORIO JUEVES - TODOS LOS USUARIOS"
          echo "ğŸ“… Fecha: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          echo "ğŸ¯ Modo: auto_all_users"
          
          response=$(curl -L -s -w "\n%{http_code}" -X POST \
            "${{ secrets.SUPABASE_URL }}/functions/v1/send-weekly-reminders" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer ${{ secrets.SUPABASE_ANON_KEY }}" \
            -d '{"mode":"auto_all_users"}' \
            --max-time 300)
          
          http_code=$(echo "$response" | tail -n1)
          body=$(echo "$response" | head -n-1)
          
          echo "ğŸ“¡ HTTP Status: $http_code"
          echo "ğŸ“„ Response: $body"
          
          if [ "$http_code" = "200" ]; then
            total_processed=$(echo "$body" | jq -r '.total_processed // 0' 2>/dev/null || echo "0")
            successful=$(echo "$body" | jq -r '.successful // 0' 2>/dev/null || echo "0")
            failed=$(echo "$body" | jq -r '.failed // 0' 2>/dev/null || echo "0")
            
            echo "âœ… Recordatorios enviados exitosamente"
            echo "ğŸ“Š Total procesados: $total_processed"
            echo "âœ… Exitosos: $successful"
            echo "âŒ Fallidos: $failed"
          else
            echo "âŒ Error enviando recordatorios"
            exit 1
          fi
