name: NFL Data Automation - Workflows Unificados

on:
  schedule:
    # Martes y Jueves 5:00 AM CDMX (11:00 UTC) - Set current week
    - cron: '0 11 * * 2,4'
    # Todos los dÃ­as 11:59 PM CDMX (5:59 UTC del dÃ­a siguiente) - Daily update
    - cron: '59 5 * * *'
    # Todos los dÃ­as 5:30 AM CDMX (11:30 UTC) - Update weekly odds
    - cron: '30 11 * * *'
    # Lunes 17:45 CDMX (23:45 UTC lunes) - Auto-assign weekly picks
    - cron: '45 23 * * 1'
    # Domingos 5:00 AM CDMX (11:00 UTC domingo) - Update live scores
    - cron: '0 11 * * 0'
    # Lunes 12:00 PM CDMX (18:00 UTC) - Recordatorio usuarios sin picks
    - cron: '0 18 * * 1'
    # Martes 12:00 PM CDMX (18:00 UTC) - Enviar resultados semanales
    - cron: '0 18 * * 2'
    # Jueves 12:00 PM CDMX (18:00 UTC) - Recordatorio a todos los usuarios
    - cron: '0 18 * * 4'

  # Permite ejecutar manualmente
  workflow_dispatch:
    inputs:
      task:
        description: 'Tarea a ejecutar'
        required: true
        default: 'all'
        type: choice
        options:
          - all
          - set-current-week
          - daily-update
          - update-weekly-odds
          - auto-update-picks
          - auto-assign-picks
          - save-weekly-records
          - update-live-scores
          - send-monday-reminders
          - send-tuesday-results
          - send-thursday-reminders
      force_execution:
        description: 'Forzar ejecuciÃ³n auto-assign (ignora validaciÃ³n de horario)'
        required: false
        default: false
        type: boolean

jobs:
  set-current-week:
    name: Actualizar Semana NFL
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'schedule' && github.event.schedule == '0 11 * * 2,4') || 
      (github.event_name == 'workflow_dispatch' && 
       (github.event.inputs.task == 'set-current-week' || github.event.inputs.task == 'all'))
    
    steps:
      - name: ğŸ“… Actualizar semana actual
        run: |
          echo "ğŸ”„ Actualizando semana actual NFL..."
          
          response=$(curl -L -s -w "\n%{http_code}" -X POST \
            "https://${{ secrets.VERCEL_DOMAIN }}/api/set-current-week" \
            --max-time 30)
          
          http_code=$(echo "$response" | tail -n1)
          body=$(echo "$response" | head -n-1)
          
          echo "ğŸ“¡ HTTP Status: $http_code"
          echo "ğŸ“„ Response: $body"
          
          if [ "$http_code" = "200" ]; then
            echo "âœ… Semana actualizada exitosamente"
          else
            echo "âŒ Error actualizando semana"
            exit 1
          fi

  daily-update:
    name: ActualizaciÃ³n Diaria de Partidos
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'schedule' && github.event.schedule == '59 5 * * *') || 
      (github.event_name == 'workflow_dispatch' && 
       (github.event.inputs.task == 'daily-update' || github.event.inputs.task == 'all'))
    
    outputs:
      update-success: ${{ steps.update-matches.outputs.success }}
    
    steps:
      - name: ğŸˆ Actualizar partidos diariamente
        id: update-matches
        run: |
          echo "ğŸ”„ Ejecutando actualizaciÃ³n diaria de partidos..."
          
          response=$(curl -L -s -w "\n%{http_code}" -X POST \
            "https://${{ secrets.VERCEL_DOMAIN }}/api/update-matches" \
            --max-time 60)
          
          http_code=$(echo "$response" | tail -n1)
          body=$(echo "$response" | head -n-1)
          
          echo "ğŸ“¡ HTTP Status: $http_code"
          echo "ğŸ“„ Response: $body"
          
          if [ "$http_code" = "200" ]; then
            echo "âœ… Partidos actualizados exitosamente"
            echo "success=true" >> $GITHUB_OUTPUT
          else
            echo "âŒ Error actualizando partidos"
            echo "success=false" >> $GITHUB_OUTPUT
            exit 1
          fi

  auto-update-picks:
    name: Auto-Update de Picks (DespuÃ©s de Update Matches)
    runs-on: ubuntu-latest
    needs: daily-update
    if: |
      (needs.daily-update.result == 'success' && needs.daily-update.outputs.update-success == 'true') ||
      (github.event_name == 'workflow_dispatch' && 
       (github.event.inputs.task == 'auto-update-picks' || github.event.inputs.task == 'all'))
    
    steps:
      - name: ğŸ¯ Actualizar picks segÃºn resultados
        run: |
          echo "ğŸ”„ Ejecutando auto-update de picks..."
          echo "â„¹ï¸  Este endpoint solo actualiza picks de partidos completados"
          
          response=$(curl -L -s -w "\n%{http_code}" -X POST \
            "https://${{ secrets.VERCEL_DOMAIN }}/api/auto-update-picks" \
            --max-time 60)
          
          http_code=$(echo "$response" | tail -n1)
          body=$(echo "$response" | head -n-1)
          
          echo "ğŸ“¡ HTTP Status: $http_code"
          echo "ğŸ“„ Response: $body"
          
          if [ "$http_code" = "200" ]; then
            echo "âœ… Picks actualizados exitosamente"
            
            # Extraer informaciÃ³n del resultado
            picks_updated=$(echo "$body" | jq -r '.picks_updated // 0' 2>/dev/null || echo "0")
            entries_updated=$(echo "$body" | jq -r '.entries_updated // 0' 2>/dev/null || echo "0")
            
            echo "ğŸ¯ Picks actualizados: $picks_updated"
            echo "ğŸ‘¥ Entradas actualizadas: $entries_updated"
          else
            echo "âŒ Error actualizando picks"
            exit 1
          fi

  update-weekly-odds:
    name: Actualizar Momios Semanales
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'schedule' && github.event.schedule == '30 11 * * *') || 
      (github.event_name == 'workflow_dispatch' && 
       (github.event.inputs.task == 'update-weekly-odds' || github.event.inputs.task == 'all'))
    
    steps:
      - name: ğŸ“Š Actualizar momios semanales
        run: |
          echo "ğŸ”„ Actualizando momios semanales..."
          
          response=$(curl -L -s -w "\n%{http_code}" -X POST \
            "https://${{ secrets.VERCEL_DOMAIN }}/api/update-weekly-odds-auto" \
            --max-time 45)
          
          http_code=$(echo "$response" | tail -n1)
          body=$(echo "$response" | head -n-1)
          
          echo "ğŸ“¡ HTTP Status: $http_code"
          echo "ğŸ“„ Response: $body"
          
          if [ "$http_code" = "200" ]; then
            echo "âœ… Momios actualizados exitosamente"
          else
            echo "âŒ Error actualizando momios"
            exit 1
          fi

  save-weekly-records:
    name: Guardar Records Semanales
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'workflow_dispatch' && 
      (github.event.inputs.task == 'save-weekly-records' || github.event.inputs.task == 'all')
    
    steps:
      - name: ğŸ“Š Obtener informaciÃ³n de temporada
        id: season-info
        run: |
          echo "ğŸ” Obteniendo informaciÃ³n de la temporada actual..."
          
          season_info=$(curl -L -s "https://${{ secrets.VERCEL_DOMAIN }}/api/current-week" --max-time 30)
          
          if [ $? -eq 0 ]; then
            year=$(echo "$season_info" | jq -r '.year // 2024' 2>/dev/null || echo "2024")
            week=$(echo "$season_info" | jq -r '.week // 1' 2>/dev/null || echo "1")
            
            # Calcular semana anterior para guardar records
            week_to_save=$((week - 1))
            if [ $week_to_save -lt 1 ]; then
              week_to_save=1
            fi
            
            echo "year=$year" >> $GITHUB_OUTPUT
            echo "week_to_save=$week_to_save" >> $GITHUB_OUTPUT
            
            echo "ğŸ“… AÃ±o: $year"
            echo "ğŸ“Š Semana a guardar: $week_to_save"
          else
            echo "âŒ Error obteniendo informaciÃ³n de temporada"
            echo "year=2024" >> $GITHUB_OUTPUT
            echo "week_to_save=1" >> $GITHUB_OUTPUT
          fi
      
      - name: ğŸ’¾ Guardar records semanales
        run: |
          echo "ğŸ”„ Guardando records semanales..."
          
          year="${{ steps.season-info.outputs.year }}"
          
          response=$(curl -L -s -w "\n%{http_code}" -X POST \
            "https://${{ secrets.VERCEL_DOMAIN }}/api/save-weekly-team-records?year=$year" \
            --max-time 45)
          
          http_code=$(echo "$response" | tail -n1)
          body=$(echo "$response" | head -n-1)
          
          echo "ğŸ“¡ HTTP Status: $http_code"
          echo "ğŸ“„ Response: $body"
          
          if [ "$http_code" = "200" ]; then
            echo "âœ… Records guardados exitosamente"
          else
            echo "âŒ Error guardando records"
            exit 1
          fi

  auto-assign-picks:
    name: Auto-Assign Picks Semanal
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'schedule' && github.event.schedule == '45 23 * * 1') || 
      (github.event_name == 'workflow_dispatch' && 
       (github.event.inputs.task == 'auto-assign-picks' || github.event.inputs.task == 'all'))
    
    steps:
      - name: ğŸ“… Log inicio
        run: |
          echo "ğŸš€ AUTO-ASSIGN SEMANAL DE PICKS"
          echo "ğŸ“… Fecha inicio: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          echo "ğŸ¯ Workflow: ${{ github.run_id }}"
      
      - name: ğŸ“Š Obtener horario del Ãºltimo partido
        id: get-schedule
        run: |
          echo "ğŸ” Consultando horario del Ãºltimo partido de la semana..."
          
          response=$(curl -L -s -w "\n%{http_code}" -X GET \
            "https://${{ secrets.VERCEL_DOMAIN }}/api/schedule-weekly-auto-assign" \
            --max-time 30)
          
          http_code=$(echo "$response" | tail -n1)
          body=$(echo "$response" | head -n-1)
          
          echo "ğŸ“¡ HTTP Status: $http_code"
          echo "ğŸ“„ Response: $body"
          
          if [ "$http_code" = "200" ]; then
            minutes_until_raw=$(echo "$body" | jq -r '.execution_schedule.minutes_until_execution // 0' 2>/dev/null || echo "0")
            minutes_until=$(printf "%.0f" "$minutes_until_raw" 2>/dev/null || echo "0")
            execution_time=$(echo "$body" | jq -r '.execution_schedule.execution_time_cdmx // "unknown"' 2>/dev/null || echo "unknown")
            current_week=$(echo "$body" | jq -r '.current_week // 0' 2>/dev/null || echo "0")
            last_match_kickoff=$(echo "$body" | jq -r '.last_match.kickoff_cdmx // "unknown"' 2>/dev/null || echo "unknown")
            
            echo "ğŸˆ Ãšltimo partido inicia: $last_match_kickoff"
            echo "â° Auto-assign programado para: $execution_time (5 min despuÃ©s)"
            echo "ğŸ“… Semana NFL: $current_week"
            echo "â³ Minutos de espera: $minutes_until"
            
            # Guardar valores para el siguiente step
            echo "minutes_until=$minutes_until" >> $GITHUB_OUTPUT
            echo "execution_time=$execution_time" >> $GITHUB_OUTPUT
            echo "current_week=$current_week" >> $GITHUB_OUTPUT
            echo "last_match_kickoff=$last_match_kickoff" >> $GITHUB_OUTPUT
          else
            echo "âŒ Error consultando programaciÃ³n"
            exit 1
          fi
      
      - name: â° Esperar hasta momento de ejecuciÃ³n
        run: |
          minutes_until=${{ steps.get-schedule.outputs.minutes_until }}
          execution_time="${{ steps.get-schedule.outputs.execution_time }}"
          
          # Si force_execution estÃ¡ activado, no esperar
          if [ "${{ github.event.inputs.force_execution }}" = "true" ]; then
            echo "ğŸš€ EjecuciÃ³n forzada - omitiendo espera"
          elif [ "$minutes_until" -le 0 ]; then
            echo "âœ… Ya pasÃ³ el tiempo de ejecuciÃ³n - ejecutando inmediatamente"
          else
            # MÃ¡ximo 6 horas de espera (360 minutos) para evitar timeout de GitHub Actions
            if [ "$minutes_until" -gt 360 ]; then
              echo "âš ï¸ Tiempo de espera ($minutes_until min) excede lÃ­mite de 6 horas"
              echo "âŒ El workflow debe ejecutarse mÃ¡s cerca del horario del partido"
              exit 1
            fi
            
            # Convertir minutos a segundos
            seconds_to_wait=$((minutes_until * 60))
            
            echo "â³ Esperando $minutes_until minutos ($seconds_to_wait segundos) hasta $execution_time..."
            echo "ğŸ• Inicio de espera: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
            
            # Esperar
            sleep $seconds_to_wait
            
            echo "âœ… Espera completada"
            echo "ğŸ• Fin de espera: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          fi
      
      - name: ğŸ¯ Ejecutar auto-assign de picks
        run: |
          echo "ğŸš€ EJECUTANDO AUTO-ASSIGN DE PICKS"
          echo "ğŸ• Hora de ejecuciÃ³n: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          
          # Ejecutar con reintentos
          max_retries=3
          retry_count=0
          success=false
          
          while [ $retry_count -lt $max_retries ] && [ "$success" = "false" ]; do
            echo "ğŸ”„ Intento $((retry_count + 1))/$max_retries..."
            
            response=$(curl -L -s -w "\n%{http_code}" -X POST \
              "https://${{ secrets.VERCEL_DOMAIN }}/api/auto-assign-last-game-picks" \
              --max-time 60)
            
            http_code=$(echo "$response" | tail -n1)
            body=$(echo "$response" | head -n-1)
            
            echo "ğŸ“¡ HTTP Status: $http_code"
            echo "ğŸ“„ Response: $body"
            
            if [ "$http_code" = "200" ]; then
              success=true
              echo "âœ… Auto-assign completado exitosamente"
              
              # Extraer informaciÃ³n del resultado
              picks_assigned=$(echo "$body" | jq -r '.picks_assigned // 0' 2>/dev/null || echo "0")
              total_entries=$(echo "$body" | jq -r '.total_entries_without_picks // 0' 2>/dev/null || echo "0")
              week=$(echo "$body" | jq -r '.week // 0' 2>/dev/null || echo "0")
              
              echo "ğŸ“Š RESULTADO:"
              echo "   ğŸ¯ Picks asignados: $picks_assigned"
              echo "   ğŸ“‹ Entradas sin pick: $total_entries"
              echo "   ğŸ“… Semana: $week"
            else
              retry_count=$((retry_count + 1))
              if [ $retry_count -lt $max_retries ]; then
                echo "âš ï¸ Intento fallido, esperando 20 segundos antes de reintentar..."
                sleep 20
              fi
            fi
          done
          
          if [ "$success" = "false" ]; then
            echo "âŒ Error: No se pudo completar auto-assign despuÃ©s de $max_retries intentos"
            exit 1
          fi
      
      - name:  Resumen final
        if: always()
        run: |
          echo "ğŸ“‹ RESUMEN DE AUTO-ASSIGN SEMANAL"
          echo "================================="
          echo "ğŸ†” Workflow: ${{ github.run_id }}"
          echo "ğŸ“… Fecha final: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          echo "ï¿½ Ãšltimo partido: ${{ steps.get-schedule.outputs.last_match_kickoff }}"
          echo "â° Tiempo de ejecuciÃ³n: ${{ steps.get-schedule.outputs.execution_time }}"
          echo "ğŸ“… Semana NFL: ${{ steps.get-schedule.outputs.current_week }}"
          echo "ğŸ¯ Forzado: ${{ github.event.inputs.force_execution || 'false' }}"
          echo ""
          echo "ğŸ”— Detalles: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"

  update-live-scores:
    name: ActualizaciÃ³n de Scores en Vivo (Domingos)
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'schedule' && github.event.schedule == '0 11 * * 0') || 
      (github.event_name == 'workflow_dispatch' && 
       (github.event.inputs.task == 'update-live-scores' || github.event.inputs.task == 'all'))
    
    steps:
      - name: ğŸ“… Log inicio
        run: |
          echo "ğŸš€ UPDATE LIVE SCORES - DOMINGOS NFL"
          echo "ğŸ“… Fecha inicio: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          echo "ğŸ¯ Workflow: ${{ github.run_id }}"
      
      - name: ğŸ“Š Obtener horarios de partidos del domingo
        id: get-sunday-schedule
        run: |
          echo "ğŸ” Consultando horarios de partidos del domingo..."
          
          response=$(curl -L -s -w "\n%{http_code}" -X GET \
            "https://${{ secrets.VERCEL_DOMAIN }}/api/get-sunday-matches-schedule" \
            --max-time 30)
          
          http_code=$(echo "$response" | tail -n1)
          body=$(echo "$response" | head -n-1)
          
          echo "ğŸ“¡ HTTP Status: $http_code"
          echo "ğŸ“„ Response: $body"
          
          if [ "$http_code" = "200" ]; then
            first_match_kickoff=$(echo "$body" | jq -r '.first_match.kickoff_cdmx // "unknown"' 2>/dev/null || echo "unknown")
            last_match_kickoff=$(echo "$body" | jq -r '.last_match.kickoff_cdmx // "unknown"' 2>/dev/null || echo "unknown")
            sunday_matches_count=$(echo "$body" | jq -r '.sunday_matches_count // 0' 2>/dev/null || echo "0")
            minutes_until_first=$(echo "$body" | jq -r '.minutes_until_first_match // 0' 2>/dev/null || echo "0")
            current_week=$(echo "$body" | jq -r '.current_week // 0' 2>/dev/null || echo "0")
            
            echo "ğŸˆ Partidos del domingo: $sunday_matches_count"
            echo "â° Primer partido: $first_match_kickoff"
            echo "â° Ãšltimo partido: $last_match_kickoff"
            echo "ğŸ“… Semana NFL: $current_week"
            echo "â³ Minutos hasta primer partido: $minutes_until_first"
            
            # Guardar valores para los siguientes steps
            echo "first_match_kickoff=$first_match_kickoff" >> $GITHUB_OUTPUT
            echo "last_match_kickoff=$last_match_kickoff" >> $GITHUB_OUTPUT
            echo "sunday_matches_count=$sunday_matches_count" >> $GITHUB_OUTPUT
            echo "minutes_until_first=$minutes_until_first" >> $GITHUB_OUTPUT
            echo "current_week=$current_week" >> $GITHUB_OUTPUT
          else
            echo "âŒ Error consultando programaciÃ³n"
            exit 1
          fi
      
      - name: â° Esperar hasta el primer partido del domingo
        run: |
          minutes_until_first_raw=${{ steps.get-sunday-schedule.outputs.minutes_until_first }}
          # Convertir decimal a entero (redondear hacia abajo)
          minutes_until_first=$(printf "%.0f" "$minutes_until_first_raw" 2>/dev/null || echo "0")
          first_match_kickoff="${{ steps.get-sunday-schedule.outputs.first_match_kickoff }}"
          
          if [ "$minutes_until_first" -le 0 ]; then
            echo "âœ… El primer partido ya comenzÃ³ o estÃ¡ por comenzar - ejecutando inmediatamente"
          else
            # MÃ¡ximo 6 horas de espera (360 minutos) para evitar timeout de GitHub Actions
            if [ "$minutes_until_first" -gt 360 ]; then
              echo "âš ï¸ Tiempo de espera ($minutes_until_first min) excede lÃ­mite de 6 horas"
              echo "âŒ El workflow debe ejecutarse mÃ¡s cerca del horario del partido"
              exit 1
            fi
            
            # Convertir minutos a segundos
            seconds_to_wait=$((minutes_until_first * 60))
            
            echo "â³ Esperando $minutes_until_first minutos ($seconds_to_wait segundos) hasta $first_match_kickoff..."
            echo "ğŸ• Inicio de espera: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
            
            # Esperar
            sleep $seconds_to_wait
            
            echo "âœ… Espera completada"
            echo "ğŸ• Fin de espera: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          fi
      
      - name: ğŸ”„ Loop de actualizaciÃ³n de scores en vivo
        run: |
          echo "ğŸš€ INICIANDO LOOP DE ACTUALIZACIÃ“N DE SCORES EN VIVO"
          echo "â° Se ejecutarÃ¡ cada 2 minutos"
          
          last_match_kickoff="${{ steps.get-sunday-schedule.outputs.last_match_kickoff }}"
          
          # Convertir last_match_kickoff a timestamp Unix para comparaciÃ³n
          last_match_timestamp=$(date -d "$last_match_kickoff" +%s 2>/dev/null || date -j -f "%Y-%m-%dT%H:%M:%S" "$last_match_kickoff" +%s 2>/dev/null || echo "0")
          
          echo "ğŸˆ Ãšltimo partido del domingo inicia a las: $last_match_kickoff"
          
          iteration=0
          max_iterations=540  # MÃ¡ximo 540 iteraciones = 18 horas (540 * 2 min = 1080 min = 18 horas)
          
          while [ $iteration -lt $max_iterations ]; do
            iteration=$((iteration + 1))
            echo ""
            echo "ğŸ”„ IteraciÃ³n #$iteration - $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
            
            # Obtener hora actual en formato ISO
            current_time=$(date -u +"%Y-%m-%dT%H:%M:%S")
            current_timestamp=$(date +%s)
            
            # Verificar si ya pasÃ³ el kickoff del Ãºltimo partido
            last_match_started=false
            if [ "$current_timestamp" -ge "$last_match_timestamp" ]; then
              last_match_started=true
              echo "âœ… Ya pasÃ³ el kickoff del Ãºltimo partido del domingo"
            fi
            
            # Ejecutar actualizaciÃ³n de scores
            response=$(curl -L -s -w "\n%{http_code}" -X POST \
              "https://${{ secrets.VERCEL_DOMAIN }}/api/update-live-scores" \
              --max-time 30)
            
            http_code=$(echo "$response" | tail -n1)
            body=$(echo "$response" | head -n-1)
            
            echo "ğŸ“¡ HTTP Status: $http_code"
            
            # Si el status code no es 200, verificar si ya pasÃ³ el Ãºltimo partido
            if [ "$http_code" != "200" ]; then
              if [ "$last_match_started" = true ]; then
                echo "âš ï¸ No hay mÃ¡s partidos en vivo y ya pasÃ³ el Ãºltimo partido"
                echo "ğŸ Finalizando loop de actualizaciÃ³n"
                break
              else
                echo "âš ï¸ Error en la actualizaciÃ³n, pero el Ãºltimo partido aÃºn no comienza"
                echo "â³ Esperando 2 minutos antes de reintentar..."
                sleep 120
                continue
              fi
            fi
            
            # Extraer informaciÃ³n del resultado
            status=$(echo "$body" | jq -r '.status // "unknown"' 2>/dev/null || echo "unknown")
            matches_updated=$(echo "$body" | jq -r '.matches_updated // 0' 2>/dev/null || echo "0")
            live_matches=$(echo "$body" | jq -r '.live_matches_found // 0' 2>/dev/null || echo "0")
            
            echo "ğŸ“Š Estado: $status"
            echo "ğŸˆ Partidos en vivo: $live_matches"
            echo "âœ… Partidos actualizados: $matches_updated"
            
            # Si no hay partidos en vivo y ya pasÃ³ el Ãºltimo partido, detener el loop
            if [ "$status" = "no_live_matches" ] && [ "$last_match_started" = true ]; then
              echo "ğŸ No hay mÃ¡s partidos en vivo y ya pasÃ³ el Ãºltimo partido del domingo"
              echo "ğŸ Finalizando loop de actualizaciÃ³n"
              break
            fi
            
            # Esperar 2 minutos antes de la siguiente iteraciÃ³n
            if [ $iteration -lt $max_iterations ]; then
              echo "â³ Esperando 2 minutos para la siguiente actualizaciÃ³n..."
              sleep 120
            fi
          done
          
          echo ""
          echo "âœ… LOOP DE ACTUALIZACIÃ“N COMPLETADO"
          echo "ğŸ“Š Total de iteraciones: $iteration"
      
      - name: ğŸ Marcar partidos del domingo como completados
        run: |
          echo "ğŸ”„ Marcando todos los partidos del domingo como completados..."
          
          response=$(curl -L -s -w "\n%{http_code}" -X POST \
            "https://${{ secrets.VERCEL_DOMAIN }}/api/complete-sunday-matches" \
            --max-time 30)
          
          http_code=$(echo "$response" | tail -n1)
          body=$(echo "$response" | head -n-1)
          
          echo "ğŸ“¡ HTTP Status: $http_code"
          echo "ğŸ“„ Response: $body"
          
          if [ "$http_code" = "200" ]; then
            matches_completed=$(echo "$body" | jq -r '.matches_completed // 0' 2>/dev/null || echo "0")
            echo "âœ… Partidos marcados como completados: $matches_completed"
          else
            echo "âš ï¸ Error al marcar partidos como completados"
          fi
      
      - name: ğŸ“‹ Resumen final
        if: always()
        run: |
          echo "ğŸ“‹ RESUMEN DE ACTUALIZACIÃ“N DE SCORES EN VIVO"
          echo "=============================================="
          echo "ğŸ†” Workflow: ${{ github.run_id }}"
          echo "ğŸ“… Fecha final: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          echo "ğŸˆ Partidos del domingo: ${{ steps.get-sunday-schedule.outputs.sunday_matches_count }}"
          echo "â° Primer partido: ${{ steps.get-sunday-schedule.outputs.first_match_kickoff }}"
          echo "â° Ãšltimo partido: ${{ steps.get-sunday-schedule.outputs.last_match_kickoff }}"
          echo "ğŸ“… Semana NFL: ${{ steps.get-sunday-schedule.outputs.current_week }}"
          echo ""
          echo "ğŸ”— Detalles: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"

  send-monday-reminders:
    name: Recordatorio Lunes - Usuarios Sin Picks
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'schedule' && github.event.schedule == '0 18 * * 1') || 
      (github.event_name == 'workflow_dispatch' && 
       github.event.inputs.task == 'send-monday-reminders')
    
    steps:
      - name: ğŸ“§ Enviar recordatorios a usuarios sin picks
        run: |
          echo "ğŸ“§ RECORDATORIO LUNES - USUARIOS SIN PICKS"
          echo "ğŸ“… Fecha: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          echo "ğŸ¯ Modo: auto_no_picks_only"
          
          response=$(curl -L -s -w "\n%{http_code}" -X POST \
            "${{ secrets.SUPABASE_URL }}/functions/v1/send-weekly-reminders" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer ${{ secrets.SUPABASE_ANON_KEY }}" \
            -d '{"mode":"auto_no_picks_only"}' \
            --max-time 300)
          
          http_code=$(echo "$response" | tail -n1)
          body=$(echo "$response" | head -n-1)
          
          echo "ğŸ“¡ HTTP Status: $http_code"
          echo "ğŸ“„ Response: $body"
          
          if [ "$http_code" = "200" ]; then
            total_processed=$(echo "$body" | jq -r '.total_processed // 0' 2>/dev/null || echo "0")
            successful=$(echo "$body" | jq -r '.successful // 0' 2>/dev/null || echo "0")
            failed=$(echo "$body" | jq -r '.failed // 0' 2>/dev/null || echo "0")
            
            echo "âœ… Recordatorios enviados exitosamente"
            echo "ğŸ“Š Total procesados: $total_processed"
            echo "âœ… Exitosos: $successful"
            echo "âŒ Fallidos: $failed"
          else
            echo "âŒ Error enviando recordatorios"
            exit 1
          fi

  send-tuesday-results:
    name: Resultados Martes - EnvÃ­o Semanal
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'schedule' && github.event.schedule == '0 18 * * 2') || 
      (github.event_name == 'workflow_dispatch' && 
       github.event.inputs.task == 'send-tuesday-results')
    
    steps:
      - name: ğŸ“Š Obtener semana actual
        id: get-week
        run: |
          echo "ğŸ” Obteniendo informaciÃ³n de la temporada actual..."
          
          season_info=$(curl -L -s "https://${{ secrets.VERCEL_DOMAIN }}/api/current-week" --max-time 30)
          
          if [ $? -eq 0 ]; then
            current_week=$(echo "$season_info" | jq -r '.week // 1' 2>/dev/null || echo "1")
            
            # Calcular semana anterior para enviar resultados
            previous_week=$((current_week - 1))
            if [ $previous_week -lt 1 ]; then
              previous_week=1
            fi
            
            echo "week_to_send=$previous_week" >> $GITHUB_OUTPUT
            
            echo "ğŸ“… Semana actual: $current_week"
            echo "ğŸ“Š Semana a enviar resultados: $previous_week"
          else
            echo "âŒ Error obteniendo informaciÃ³n de temporada"
            echo "week_to_send=1" >> $GITHUB_OUTPUT
          fi
      
      - name: ğŸ“Š Enviar resultados semanales
        run: |
          echo "ğŸ“Š RESULTADOS SEMANALES - MARTES"
          echo "ğŸ“… Fecha: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          echo "ğŸ¯ Modo: auto_all_users"
          echo "ğŸ“… Semana: ${{ steps.get-week.outputs.week_to_send }}"
          
          response=$(curl -L -s -w "\n%{http_code}" -X POST \
            "${{ secrets.SUPABASE_URL }}/functions/v1/send-weekly-results" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer ${{ secrets.SUPABASE_ANON_KEY }}" \
            -d '{"mode":"auto_all_users","week":${{ steps.get-week.outputs.week_to_send }}}' \
            --max-time 300)
          
          http_code=$(echo "$response" | tail -n1)
          body=$(echo "$response" | head -n-1)
          
          echo "ğŸ“¡ HTTP Status: $http_code"
          echo "ğŸ“„ Response: $body"
          
          if [ "$http_code" = "200" ]; then
            total_processed=$(echo "$body" | jq -r '.total_processed // 0' 2>/dev/null || echo "0")
            successful=$(echo "$body" | jq -r '.successful // 0' 2>/dev/null || echo "0")
            failed=$(echo "$body" | jq -r '.failed // 0' 2>/dev/null || echo "0")
            
            echo "âœ… Resultados enviados exitosamente"
            echo "ğŸ“Š Total procesados: $total_processed"
            echo "âœ… Exitosos: $successful"
            echo "âŒ Fallidos: $failed"
          else
            echo "âŒ Error enviando resultados"
            exit 1
          fi

  send-thursday-reminders:
    name: Recordatorio Jueves - Todos los Usuarios
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'schedule' && github.event.schedule == '0 18 * * 4') || 
      (github.event_name == 'workflow_dispatch' && 
       github.event.inputs.task == 'send-thursday-reminders')
    
    steps:
      - name: ğŸ“§ Enviar recordatorios a todos los usuarios
        run: |
          echo "ğŸ“§ RECORDATORIO JUEVES - TODOS LOS USUARIOS"
          echo "ğŸ“… Fecha: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          echo "ğŸ¯ Modo: auto_all_users"
          
          response=$(curl -L -s -w "\n%{http_code}" -X POST \
            "${{ secrets.SUPABASE_URL }}/functions/v1/send-weekly-reminders" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer ${{ secrets.SUPABASE_ANON_KEY }}" \
            -d '{"mode":"auto_all_users"}' \
            --max-time 300)
          
          http_code=$(echo "$response" | tail -n1)
          body=$(echo "$response" | head -n-1)
          
          echo "ğŸ“¡ HTTP Status: $http_code"
          echo "ğŸ“„ Response: $body"
          
          if [ "$http_code" = "200" ]; then
            total_processed=$(echo "$body" | jq -r '.total_processed // 0' 2>/dev/null || echo "0")
            successful=$(echo "$body" | jq -r '.successful // 0' 2>/dev/null || echo "0")
            failed=$(echo "$body" | jq -r '.failed // 0' 2>/dev/null || echo "0")
            
            echo "âœ… Recordatorios enviados exitosamente"
            echo "ğŸ“Š Total procesados: $total_processed"
            echo "âœ… Exitosos: $successful"
            echo "âŒ Fallidos: $failed"
          else
            echo "âŒ Error enviando recordatorios"
            exit 1
          fi
